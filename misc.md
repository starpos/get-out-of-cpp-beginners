## その他

ここでは、書いてみたものの分量が多くなかった雑多な話題について、まとめておきます。


### 入力のチェック

プログラム外部からの入力は、必ず動的に(実行時に)チェックしましょう。
これがセキュリティの脆弱性を生まないための大原則です。
入力データをチェックなしに実行することは危険です。
入力が何らかの形で実行される恐れがある場合は、文字列エスケープなどの処理で危険な操作をされないようにする必要があります。
また、入力データのサイズにも注意しましょう。
必ず現実的な上限を設定しておき、それに従ってチェックすることが肝心です。
バッファオーバーフローという古から使われる有名な攻撃手法は、まさに想定外の長い入力を与え、それをプログラムが受けいれてしまうことによって引き起こされます。


とはいえ、無闇に入力をチェックすると、チェックを無駄に複数回実施することになり、性能が低下してしまいますので、
プログラムの内外の境界について意識して、外から内に入ってくるデータについてチェックするようにしましょう。
また、`assert` はデバッグやテスト用途で便利ですが、通常リリースビルドでは有効化されないものです。
ですから、セキュリティのための入力チェックを目的として `assert` を使わないようにしましょう。


### コンパイラ特有の話

いくつかあるので列挙しておきます。


#### コンパイラオプション

GCC や Clang のコンパイラオプションには、 `-Wall -Wextra` を必ず付けて多くの warning を出してもらいましょう。
そして、warning が出なくなるまでコードを修正しましょう。
Warning が出るということはリスクのあるコードであることを意味しますし、たくさん warning が出る状態を放置すると、コード修正のときに邪魔になりますし、問題が埋もれて見過される原因になりますので、やめましょう。

`-pedantic` は ISO C/C++ に準拠しない文法や記法は禁止するというコンパイラオプションです。
場合によっては使いましょう。
いわゆる GCC 拡張が使えなくなります。


#### C++標準とコンパイラとCPU

C++ 標準の話と、コンパイラが受けいれる記法や生成するコードの話と、CPU 内部でどう実行されるかの話は、
繋がってはいますが厳密には違うレベルの話なので、区別して考えましょう。
例えば、メモリオーダーの話などがそれに当たります。ここでは詳細について語るのは控えます。


#### 環境による int や long サイズの違い

Linux や Windows などの環境の違いによる long や unsigned long のサイズの違いには気をつけましょう。
64bit Linux では、long は 64bit ですが、64bit Windows では 32bit です。
64bit Windows の上で動く環境でも、64bit Cygwin では 64bit だったり、64bit MinGW では 32bit だったり、WSL (Windows Subsystem for Linux) ではやっぱり 64bit だったりします。
これらの基本型のサイズのバリエーションは、LLP64、LP64、ILP64 などと呼んで区別するようです。
Windows や MinGW は LLP64、Linux、Cygwin, WSL は LP64 です。ちなみに ILP64 は int も 64bit になるものです。


#### ヘッダの重複インクルード回避

ヘッダファイルは同じ内容が複数回読まれないようにファイル先頭に `#ifndef HEADER_NAME` `#define HEADER_NAME`と ファイル末尾に`#endif` を書くことで、一度しか読まれないことを保証する方法が昔は一般的でした。
しかしこの方法は名前 (`HEADER_NAME`) の衝突や、`#ifndef` と `#endif` の対応がおかしくなり得るなどの面倒くささを抱えています。
 昨今は、多くのコンパイラが `#pragma once` という記法をサポートしていて、ヘッダファイルの先頭にこれを 1 行書くだけで、一度しか読まれないことが保証されるようになりましたので、是非こちらを使ってください。

#### マクロ

マクロは、C 言語の時代から使えるものでしたが、プリプロセッサで処理され、ソースコード文法の解釈なしで文字列置換を基本とした処理がなされる仕組みなので、危険がいっぱいです。
定数の定義にマクロを使う伝統もありましたが、C++ では適切な名前空間に const 変数を定義して使うようにしましょう。
コードジェネレータとして使う場合は、テンプレートで代用できないかを検討しましょう。
どうしても使わなければならない場面もあるとは思いますが、出来るだけ少なく留めるのが良いと思います。
また、マクロはヘッダライブラリなども含めて名前空間がひとつしかないので、自分がマクロを定義するときは、多少長くなるのは仕方ないものとして、適切なプレフィックスやサフィックスを付けて名前が衝突しづらくなるようにしましょう。

#### インライン展開

`inline` 指定では必ずしもインライン展開してくれるわけではないので、必ずインライン展開したい関数は、コンパイラに強制する必要があります。
GCC や Clang だと `__attribute__((always_inline))` を使います。


#### Makefile の依存関係ファイル

- GCC や Clang でソースファイルをコンパイルするときに `-MMD` `-MP` の両方のオプションを指定しておくと、`make` コマンドが解釈できる依存関係ファイルを `.d` 拡張子のファイルとして出力してくれます。
その一方で Makefile に以下のように書いておけばよろしく依存関係を解釈してくれます:

```
ALL_SRC=$(wildcard *.cpp)
DEPEND_FILES=$(ALL_SRC:.cpp=.d)
-include $(DEPEND_FILES)
```

### ヘッダとソース

ヘッダファイルは `.hpp` や `.h` などの拡張子を持ち、原則プロトタイプ宣言だけが書かれていて、
ソースファイルは `.cpp` や `.cc` などの拡張子を持ち、関数やメンバ関数の内容が書いてあるものです。
注意点として、テンプレートは、ファイルローカルでしか使われないものを除いてヘッダファイルに内容を記述しないといけません。
また、インライン展開したい実装は、やはりファイルローカルでしか使われないものを除いてヘッダファイルに書く必要があります。
ソースファイルに書いた実装は、LTO (Link-Time Optimization) の最適化を除いて必ず通常の関数呼び出しとなります。
`main()` 以外の実装をヘッダファイルに書くというスタイルもあり得ますが、複数の実行ファイルを生成する前提で、
コード量が増えてくると、同じヘッダファイルに含まれる同じコードを複数回コンパイルすることになり、コンパイル時間が長くなってきてしまいます。
インライン展開が必要なコードはプログラムの中でごくごく一部でしょうから、あとのコードは大人しくソースファイルに書きましょう。

ヘッダファイルは、歴史的経緯からこのような仕組みとなっているもので、ヘッダの取り込み順序で挙動が変わってしまったり、
複数回の取り込みによるコンパイル時間の増大などの問題があります。
より現代的で便利なモジュールの仕組みを導入しようとする動きが C++ 標準の方であるようです。
対象の公開範囲を調節するだとか、名前を適切に変えて取り込むだとかのメンテナンス性に直結する機能ですので、是非実現して欲しいですね。


### ラムダ式

C++11 で搭載されたラムダ式は、ちょっとした即席の関数オブジェクトを作って関数に渡したいときに便利だと思います。
ただ、やはり使いすぎは禁物です。
というのは、ラムダ式の参照キャプチャを使うと、実質的にラムダ式の外側のスコープにアクセスできるからです。


```c++
void func()
{
    int i = 0;
    // ...
    auto predicate = [&i]() {
        i = 1;
    };

    predicate();
    // i == 1
}
```

この例くらいならかわいいものですが、ラムダ式が巨大化して、参照する変数も増えると、コードの見通しはかなり悪くなってしまいます。
そうなる前に、一部をきちんと名前のある通常の関数として切り出すなどのリファクタリングを行うことをオススメします。

C++14 で追加されたジェネリックラムダ、C++17 で追加された `constexpr` ラムダなど、ラムダ式も機能が増えていますが、
やはり実際にどんな挙動をするかを分かった上で、可読性についても十分考慮して使ってください。
曖昧な理解のままで使うくらいなら使わない方がずっとマシです。


### auto や decltype

C++11 で使えるようになって、その後 C++14 や C++17 で改善され続けている [auto](https://en.cppreference.com/w/cpp/language/auto)や [decltype](https://en.cppreference.com/w/cpp/language/decltype) は、利用範囲が増えてきました。
テンプレートを定義する場合は、これらを使わないと実装が難しいものもあるようですが、通常の関数内で、気軽に使うのはよく考えてからにしましょう。
コードの可読性という視点では、明らかに分かるもの以外で `auto` や `decltype` を使うのはオススメできません。
例えば、[range-based for loop](https://en.cppreference.com/w/cpp/language/range-for)  の要素を受ける変数宣言や、イテレータを返す関数を受ける変数宣言などは、人間が見ても型が推論しやすいでしょうから、`auto` などを使っても読み易さが落ちづらく、
かつ長ったるい型名の記述が減って書く側も読む側もうれしいことでしょう。
それからラムダ式に名前を付けるときは `auto` を使うのが典型的な使い方です。
私はこの 3 つのケースについてはあまり気にせずに `auto` を使っています。
繰り返しますが、型推論してくれるからといって安易に `auto` や `decltype` を使うのはやめましょう。


### コンテナとイテレータ

どのコンテナをどのように使うべきかについては、多くの資料がありますから参考にしてください。
ある型のオブジェクトからなる集合を管理するコンテナとして `std::vector`、 `std::list`、 `std::deque` などがありますが、性能特性が違うので、アクセスの方法によって使いわけられるべきもの達です。
また、`std::map` と `std::unordered_map` は key-value 型のデータを格納するためのものです。
木構造か、ハッシュテーブルかで実装が分かれ、性能特性や能力も違います。
コンテナのメンバ関数は、C++ 標準で計算量などの制約が付けられていたりします。
例えば、`size()` メンバは必ず計算量 `O(1)` で実行できることなどです。
標準で性能基準が定められているものは、実装も制約を受けていますので、コンパイラやそのバージョンによらず、性能特性が担保されることが期待できます。


イテレータについて覚えておいて欲しい重要なことが 2 つあります。
ひとつ目は、範囲の扱い方です。範囲を考えるときに
`begin()` は閉じていて(範囲に含まれる) `end()` は開いている(範囲に含まれない)ことを覚えておいてください。

```c++
{
    std::vector<int> v;
    v.reserve(10);
    for (size_t i = 0; i < 10; i++) {
        v.push_back(i);
    }
    // v.size() is 10.

    // Iterator
    for (auto it = v.begin(); it != v.end(); ++it) {
        ::printf("%d\n", *it);
    }
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

    // Range-based for
    for (int i : v) {
        ::printf("%d\n", i);
    }
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

    // Index
    for (size_t i = 0; i < v.size(); i++) {
        ::printf("%d\n", v[i]);
    }
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
}
```

上記はどれもコンテナの全要素を for 文で回す方法です。
Range-based for 文は裏で iterator を回しているだけです。
`std::vector` や `std::deque` などは添字演算子 (上では `v[i]`) によるアクセスも使えます。
`v.begin()` は先頭の要素を指しますが、`v.end()` は最後の要素を指していません。
多くの場合、`std::vector` の `end()` は
`&v[v.size()]` に相当するアドレスを格納していると思います。

イテレータに限らず範囲という概念を考えるときはこのルールを守るのが良い戦略だと思います。
その理由は、範囲の分割や隣合う範囲の集約操作が簡単だからだったり、
`0` 始まりの for 文において終点と実行回数が一致するという分かりやすさもあるかと思います。
begin が 0 で end が 10 の範囲は、0, 1, 2, 3, 4, 5, 6, 7, 8, 9 という列です。
一番基本的な `for` 文は、以下のように書くことが多いと思います:

```c++
{
    // size_t n;
    std::vector<int> v(n);
    for (size_t i = 0; i < n; i++) {
        // v[i] にアクセス
    }
}
```
これは、`0`, `1`, ..., `n-1` までの `n` 回実行される for loop です。
逆順のアクセスは、

```c++
{
    std::vector<int> v(n);
    for (size_t i = n; i > 0; i--) {
        // v[i - 1] にアクセス
    }
}
```
このように書くと分かりやすいと思います。
慣れれば、始点と終点の扱いを気にする頻度が減り、
典型的な操作においてはバグったコードを書けなくなると思いますので、
begin は閉じていて、end は開いているパターンを使うように心掛けましょう。


イテレータについて覚えておいて欲しい重要なことのふたつ目は、
コンテナの操作によって特定のイテレータが無効化されることです。
例えば、
[`std::map::erase`](https://en.cppreference.com/w/cpp/container/map/erase)
の説明で、
"References and iterators to the erased elements are invalidated. Other references and iterators are not affected."
と書いてあります。削除された参照やイテレータは無効となるが、他の(要素を指している)イテレータは無効化されない、
ということですね。
無効となったイテレータを再初期化(再代入)すれば変数としては再利用できますが、
再初期化しないままで操作をしてはいけません。
例えば `std::map::erase` でキーが偶数の要素を削除する操作をコードにしてみましょう。

```c++
{
    std::map<int, int> m{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};

    auto it = m.begin();
    while (it != m.end()) {
#if 0  // 悪い例
        if (it->first % 2 == 0) {
            m.erase(it); // it は invalidated になる
        }
        ++it;  // invalidated になった it を操作してしまっている
#else  // 良い例
        if (it->first % 2 == 0) {
            it = m.erase(it);  // 消された次の要素を指す
        } else {
            ++it;
        }
#endif
    }
    for (const auto& p : m) {
        ::printf("%d\n", p.first);
    }
    // 1, 3, 5
}
```
`m.erase(it)` は `it` が指していたイテレータを無効化しますので、
悪い例では無効化された `it` に対して `operator++()` を呼んでしまっており、
不定な動作をします。
ただ、上記のような用途のためだと思いますが、`m.erase()` は
次の要素(最後だった場合は `m.end()`)のイテレータを返しますので、
`it = m.erase(it)` を使えばやりたいことが出来ます。
このような細かい挙動はドキュメントにきちんと書いてありますので、
疑問に思ったら確認してください。


### boost ライブラリ

[boost ライブラリ](https://www.boost.org/)は C++ の標準ライブラリではありませんが、一部の機能が C++ 標準に取り込まれた実績が多くあるライブラリです。
つまり、boost に入っている機能は次世代の C++ 標準に取り込まれる可能性があります。


自分の使いたい道具が C++ 標準になくて、boost にあったなら、使いたくなるのは当たり前です。
しかし、ちょっと待ってください。
あなたの書こうとしているプログラムは何年使われるものですか？何年メンテナンスする必要のあるものですか？boost は先進的なライブラリなので、古いバージョンは新しいコンパイラでビルドできなくなるかも知れませんし、新しいバージョンの boost ライブラリは API が変わっているかも知れません。
OS のパッケージシステムなどで提供される boost はバージョンがひとつしか選べないか、選べても少ないでしょうし、新しいバージョンの OS には新しい boost が入っています。
あなたのプログラムのメンテナンスのことを考えて、boost を使うかどうかを決めると良いでしょう。
boost のヘッダライブラリだけを使う分には、相対的には互換性問題が発生するリスクが少ないと思います。
