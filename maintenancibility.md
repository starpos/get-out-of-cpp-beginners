## メンテナンス性

本書の読者の方々には、是非メンテナンス性を重視してコードを書いてもらいたいと思っています。
メンテナンス性は必ずしも C++ 特有の話ではなく、プログラミング、ソフトウェア設計実装において重要な話題ですが、
とりわけ C++ は一歩間違えるとコードや実行結果が大変なことになる気難しい側面がありますので、
ここではメンテナンス性についてもう少し具体的に考えてみたいと思います。
メンテナンス性が良いとは、コードの読み手がより少ない労力や時間で必要な情報を得られることと、より少ない労力や時間で必要とするコード修正やテストを行えることだと思います。
つまり、読みやすく、修正しやすいということです。
読みやすさ、修正しやすさを定量的に表すのは難しそうですが、
長い期間使われるコードであればあるほど、コードやドキュメントのメンテナンス性の良さはソフトウェアのコスト対効果の向上に大きな貢献をします。
コードを書くとき、レビューするときは、以下の複数の観点から、よりメンテナンス性の良いコードにするにはどうしたら良いかということを考えてください。


### 名前

変数、関数、クラスの名前はメンテナンス性にとって重要です。
「名は体を表す」の諺通り、中身を読まなくてもその挙動を推測するのに役立ちます。
無意味な名前や、とんちんかんな名前がついていると、読み手は中身を読んでその意味を理解する必要があったり、
誤解して正しい理解を妨げてしまったりします。
良い名前をつけましょう。
品詞の使い分けについては様々な場所で言及されていますので、ここでは議論しません。
ラムダ関数が無名で許されるのは、ひと目見れば内容が分かるくらい単純なもので、わざわざ名前をつけなくても内容の把握が簡単だからなのです。
当然、ひと目見て何をやっているのか分からないようなラムダ関数を作るべきではありません。

名前の長さについて。原則として意識して欲しいのは、
スコープの小さいものについては短くすること、
スコープが大きいものについては長くすることです。
数行しかスコープがないのに、`aaa_bbb_ccc` などと仰々しい名前をつけられるとかえって読み手の理解を妨げます。
なぜなら、読み手は `aaa` の `bbb` の `ccc` と毎回解釈するのに時間をつかってしまうからです。
短い名前とは、識別子(ラベル)、ひとつの単語、単語の省略形、だと思います。
識別子について、`i, j` は整数を表すのによく使いますし、
`p` はポインタ、`s` はサイズ、`e` はエラー、などでよく使います。
同じような変数が 2 つ以上ある場合はそれらを効率良く区別できるようにする必要があります。
スコープが十分小さくて読み手が混同しないと期待されるのであれば、 `i1`, `i2` でも良いのですが、
prefix や suffix をつけて区別することもあるでしょう。
単語の省略形も場合によっては使います。`size` は `sz` とか、`error` は `err` とか、
`iterator` は `itr` とか `iter` などです。もちろん名前が自明ではないときはコメントで補いましょう。
ただし、コメントで補うまえに、名前を本当にそこまで短くすべきなのかないか自問自答しましょう。

グローバル変数やグローバル関数はスコープが大きいことが多いので、
出来るだけ名前の省略はしないようにしましょう。ただし多用するものは名前を短くしたくなる場合もあるでしょう。
大原則を思い出しましょう。これはメンテナンス性(読みやすさ)のためにやっていることです。
短くすると分かりづらくなることと短い方が読むときに早く解釈できる/コードがすっきりすることの
トレードオフがありますので、バランスの良いところで決めるのが良いでしょう。

クラスのメンバ関数は、そのクラスの、というコンテクストが常につきまとうため、
グローバル関数よりも短い名前にしやすいです。
クラス変数やクラスの中で定義されている型については、
クラス名が名前空間と見做せるため、クラス外から使うとしてもやはり短い名前にしやすいと思います。
クラス内部でのみ使う型の名前はさらに短くても大丈夫かも知れません。

名前空間で型や関数などをうまく分類できるならそれを活用することで、
それらの名前を短くすることもできるでしょう。

関数や型の名前を定義側ではなくそれらを使う側で短くすることもできます。
`using` (`typedef`) を使うことで型に別名をつけることができます。
テンプレートなどで長くなってしまう型については短い別名をつけることはよくあります。
`using MapVec = std::vector<std::map<std::string, std::string>>;` などですね。
原則を忘れないでください。スコープが小さかったり多用するなら短い名前で良いのですから、
適切なスコープ内で別名を定義してください。

現在の名前空間にある名前空間を直接取り込む `using namespace` がありますが、
使う側で名前を短くしたいからといってこれをを使うのは原則としてやめましょう。
名前空間を混ぜると変更への追随コストが上がるからです。
`using namespace std;` は特にオススメしません。
私は `int` やら `size_t` やら `uint64_t` などのプリミティブ型については `std::` をつけませんが、
`std::string` や `std::vector` は `std::` をつけて使っています。
ひとつの理由は `std::` がないと(クラス)型として識別しづらいからです。
もちろんこれらが組み合わさって型名が長くなる場合は `using` を使って個別に別名をつけましょう。
`namespace aaa = bbb::ccc::ddd;` などとすることで、名前空間そのものに別名をつけることができます。
これも必要に応じて活用しましょう。これを使いたくなるのは同一の長い名前空間にある型をたくさん
使いたいときでしょう。

名前ルールを別にすることで、大まかに識別子を分類することも読み易さを助けます。
私が使っているのは

- 型名: `UpperCamelCase` (もしくは `Upper_Snake_Case`)
- (メンバ)関数名や変数名: `snake_case` (もしくは `lowerCamelCase`)
- 定数: `SCREAMING_SNAKE_CASE`

です。

もちろん自分がいちから作ったわけではないコードを修正するときは、
そこで使われている命名規則に合わせるべきなのはいうまでもありません。



### 型

C++ は静的型付け言語に分類されます。
ほとんどの変数やオブジェクトの型が静的に、すなわちコンパイル時に解決されます。
そのルールを逸脱するコードはコンパイルエラーとなります。
Python などの動的型付け言語に比べれば、プログラムを動かす前に型による制約を守っていることが求められるので、わずらわしいと思う人がいるかも知れません。
しかし、メンテナンスの観点からは、静的型付け言語はとても重要な性質を持っています。
それは、コンパイルが通った時点で型エラーは排除されているいうことです。
すなわち、実行しているときに、ある変数と実際のオブジェクトの型が異なって、やろうとしている操作が出来ないという問題は起きないということです。
動的型付け言語では、型エラーの可能性を、テストを充実させることで排除するアプローチを取ります。
ただ、テスト漏れの可能性が常にあることを考えれば、静的片付け言語に比べて非力であることは否めません。
特に長期間のメンテナンスを考えた場合、静的型付け言語が有利だと思います。

C++ において静的に型が決まらない例外もあります。
ひとつは virtual メンバ関数を使って多態しているオブジェクトを格納するポインタに対する `dynamic_cast` です。
これに関しては静的に型が決定せず、動的に型が解決されるため、プログラムのロジックが間違っていれば、`dynamic_cast` に失敗し、セグメンテーションフォールトをするなど不正な動作となります。
もうひとつは、`reinterpret_cast` や C 言語のキャストなどの強制的なキャストです。
強制的なキャストは、コードを書いた人の責任で「無理矢理」そのオブジェクトを別の型であると見なす行為ですから、
その対象が互換性があることを保証する責任はコンパイラではなくコードを書いた人が負います。
もちろん不具合があれば期待通りに動かなかったり、不正な挙動をしてデータが壊れたりします。
キャストは型エラーの可能性を生み出す行為なので、
コンパイラが型で守ってくれる世界から逸脱する行為であることに十分注意してください。


### コメント

コメントは読み手の理解を助けます。
つまりメンテナンス性に寄与します。
コードを読めば分かることは書かないようにしましょう。
読み手にとって二度手間になることでむしろ読みにくくなってしまいます。
主に何故そうしたのか、コードを読んだだけでは分かりにくいと思われるときに書きます。
複数のやり方があり得たがなぜそれを選んだのか、そのコードの実行結果は何をもたらすのか、生成物は何に使われるのか、などです。
What ではなく Why を書くようにしましょうと良く言われます。
What だとしても、まとまったコードが何をしているのかを短いコメントで説明するのは意味があると思いますが、
そうしたくなったときは、関数として分離できないか検討しましょう。
同様に、変数や関数の名前を短くしたいときにも、意味を補う目的でもコメントを使いましょう。
その場合、名前を短くしてコメントで補うべきなのかコメントなしで名前に情報を持たせるかのトレードオフを考えて判断するようにしましょう。


### 部品化

同じ処理が複数の箇所に存在しているとメンテナンス性に悪影響を与えます。
**DRY** (*Don't Repeat Yourself*) 原則と呼ばれますが、コードだけでなくドキュメントやコメントも含めて情報の重複を避けることが求められています。
ある箇所を修正したら、同じ情報が書いてある別の箇所も修正する必要がある場合、DRY 原則に違反しているといえます。
部品化しましょう。
部品化とは、複数の変数や引数をひとつのクラスにまとめたり、複数行のコードを関数として独立させたりすることです。
コード量が単純に減ることで、潜在的にはコードを読む労力が減りますし、重複がないということは、修正の労力も減りますし、修正し忘れを防止できます。


制御構造がコードに埋もれるとメンテナンス性に悪影響を与えます。
`if` や `for` などの制御ブロック内に、大量のコードがあったり、その場での入れ子構造が何重にもなっている状態は、良くありません。
コードを読む場合、制御構造は今どこを読むべきかを判断するための重要な情報なので、埋もれると読みづらくなります。
また、制御構造を変更・修正する場合、制御ブロック内に大量のコードがあると、これらの一部または全部を移動するテキスト編集が必要となり、その際にミスが起きやすくなります。
このような処理は、たとえ 1 回しか呼ばれないとしても、部品化を検討しましょう。


たった 1 行の処理も部品化すべきでしょうか？ 場合によっては「すべき」といえます。
例えば、何をやっているか一見分からない処理が 1 行で書かれていて、そのような処理が複数箇所で行われていて、その処理を良い名前で表現できるときなどです。
1 箇所でしか使わないなら、コメントにその名前を書いておくのでも良いでしょう。
インライン展開されれば関数呼び出しのオーバーヘッドはありませんので、余程大量に呼ばれる処理でなければ気にせず関数として切り出し、気になるのであれば明示的なインライン化をコンパイラにお願いしましょう。


度重なる修正でクラスのメンバ変数が増えすぎたとき、関数内で定義されるローカル変数が増えすぎたとき、ひとつの関数に渡す引数が多すぎるときも、部品化を検討しましょう。
複数のメンバ変数をまとめて別のクラスに分離したり、複数のローカル変数や引数をまとめてクラスとして定義したり、関数内の一部の処理を別の関数として分離したり、です。
具体的にどのくらいの数や量なら多すぎるのかについては言いづらいですが、
あなたがコードレビューする立場であれば、多いな、と思ったら迷わずそれを指摘し、
部品化するメリットやデメリットについて議論するようにしましょう。


一方、部品化のやりすぎも禁物です。
少しコードが減るからといって、共通の部品にしなければ不要だった `if` 文をむやみに発生させるのはよくありません。
そのような `if` 文が増えてきたらそれは部品をふたつもしくはそれ以上の数に分離させるべき合図です。
コピーして、別の名前をつけ、不要になった `if` 文を削除します。
あくまで部品化は、メンテナンス性向上ための手段のひとつであり、部品化を目的化してはいけません。


###  疎結合

関数やクラスなどの部品同士が疎結合になっているかどうかも、メンテナンス性に影響します。
例えば、あるクラスだけを見たとき、公開しているメンバ変数や関数インターフェースが少なく、それを呼ぶ箇所が少なくできるならその方がより疎結合だといえるでしょう。
同様に、関数の引数が少ない方が疎結合でしょう。
より疎結合であれば、ある処理を追うときに読まなければならないコード量が減ります。


疎結合であることを、より具体的に表現するとしたら、グラフ構造を使うのが適切かと思います。
モデル化の方法はいくつか考えられますが、例えば関数やクラスがノードで、それらを引数で渡したり関数内で呼んだりするのがノード間のエッジに相当すると考えてみましょう。
グラフ構造が疎結合であるとは、ノードあたりのエッジ本数が少ないことを意味します。
異なる機能を実現するコード同士で比較できるものかは分かりませんが、少なくとも同じ機能を実現するためのコード同士、リファクタリング前と後を比較するときに、このようなグラフ構造を考えて、エッジ本数が少ない方がよりメンテナンスしやすいコードであるとは言えると思います。
ソフトウェア工学の分野では、このような構造か、別の構造を用いた、より良い指標があるかも知れませんので、興味のある方は調べてみて下さい。私はあまり詳しくありません。


部品化を行うと、上で考えたグラフ構造の上では、ノード数が増え、エッジ数も増えると思います。
大きな関数やクラスを部品とみれば、それらの依存関係は疎結合だったとしても、より細かい単位での部品をノードだと考えれば、依存関係がクラス内や関数内に存在し、それらが実際は密結合であるにも関わらず、その事実が隠れてしまっているだけだったりします。
通常は、部品化を優先させ、それが十分満たされたと判断してから、クラスや関数単位での疎結合化を考えるのが良いと思います。


### const

const を適切に使うことがメンテナンス性に大きな貢献をすることは既に説明しました。
その理由は、繰り返しになりますが、const であるべきものが const になっていると、
コードを読むとき、修正をするときに、const を見て「これは変更されない」と判断でき、
読む量が減るからです。

グラフ構造を使ってソフトウェアは疎結合の方が良いと説明しましたが、
non-const と const のアクセスでエッジの重み(もしくは線の太さ)を変えることとし、
non-const よりも const の方が重みは小さい(線は細い)こととすれば、
const を使った方がメンテナンス性が良いことを表現できるかと思います。
const を適切に使うと、ソフトウェアがより疎結合になる、そんなイメージを持って下さい。


### テスト

メンテナンス性の担保にテストは欠かせません。
特に、定期的に、もしくはコードの修正が反映された契機にテストを実行してくれる CI (Continuous Integration) ツールの利用は、
我々が安心してコードを修正するのに必須といっても過言ではないです。
コード修正によるリグレッションは長期間メンテナンスするコードでは特に気をつけなければなりません。
リグレッションとは、コードの修正が、かえって不具合を埋めこんでしまうことを指します。
少なくとも、テストを書いてそれを CI ツールで動かすようにしていれば、テストが通らないことでリグレッションの発生をすぐに検知でき、
修正するなどの対応ができます。
テストがカバーしていない領域で発生する不具合は防げませんが、典型的なユースケースは大抵テストがカバーしていますので、
うっかりミスにすぐ気付けるだけでも有り難いものです。

様々なテストフレームワークがありますが、何を使うとしても CI ツールでリグレッションテストを実行することを意識しておけば良いと思います。
ごくごく単純なユニットテスト用途で十分なものとして、[cybozulib](https://github.com/herumi/cybozulib) の `test.hpp` をオススメしておきます。


```c++
#include "cybozu/test.hpp"

CYBOZU_TEST_AUTO(test_a)
{
    int i = 0; j = 0;
    CYBOZU_TEST_EQUAL(i, j);
    CYBOZU_TEST_ASSERT(i == 0);
}
```
このように書いてコンパイルすると、テスト成功時は 0 、失敗時はそれ以外が返る実行ファイルが出来ます。

環境の整備や初期化などが必要なテストは、もっと複雑な機構が欲しくなるかも知れませんが、必要に応じてスクリプトを作ったりして対応すれば良いと思います。
実行したらテスト成功か失敗かを判別できる出力をし、自動化しやすい形でプログラムとして作っておくのが重要です。
